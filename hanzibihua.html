<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AI æ±‰å­—ç§æ•™ (Geminiç‰ˆ)</title>
<script src="https://cdn.jsdelivr.net/npm/hanzi-writer@3.5/dist/hanzi-writer.min.js"></script>
<style>

        :root { --primary-color: #4a90e2; --bg-color: #f5f7fa; --card-bg: #ffffff; }

        body { font-family: 'Segoe UI', 'PingFang SC', sans-serif; background-color: var(--bg-color); display: flex; flex-direction: column; align-items: center; min-height: 100vh; margin: 0; padding: 20px; }

        h1 { color: #333; margin-bottom: 20px; }

        /* æœç´¢æ¡†æ ·å¼ */

        .search-box { display: flex; gap: 10px; margin-bottom: 30px; background: white; padding: 10px; border-radius: 50px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }

        input { border: none; font-size: 18px; padding: 10px 20px; outline: none; width: 120px; text-align: center; }

        button.search-btn { background-color: var(--primary-color); color: white; border: none; padding: 10px 25px; border-radius: 40px; cursor: pointer; font-size: 16px; transition: 0.2s; }

        button.search-btn:hover { background-color: #357abd; }

        button.search-btn:disabled { background-color: #ccc; cursor: not-allowed; }

        /* å¸ƒå±€ */

        .container { display: flex; flex-wrap: wrap; gap: 40px; background: var(--card-bg); padding: 40px; border-radius: 20px; box-shadow: 0 10px 25px rgba(0,0,0,0.05); max-width: 800px; width: 100%; justify-content: center; }

        /* å†™å­—åŒº */

        .writer-section { display: flex; flex-direction: column; align-items: center; }

        #character-target-div { box-shadow: 0 0 10px rgba(0,0,0,0.1); border-radius: 4px; background: #fff; }

        .controls { margin-top: 15px; display: flex; gap: 10px; }

        .btn-sm { padding: 8px 16px; border: 1px solid #ddd; background: white; border-radius: 6px; cursor: pointer; font-size: 14px; transition: all 0.2s; }

        .btn-sm:hover { background: #f0f0f0; }

        /* ä¿¡æ¯åŒº */

        .info-section { flex: 1; min-width: 300px; }

        .header-group { display: flex; align-items: baseline; gap: 15px; margin-bottom: 20px; border-bottom: 2px solid #f0f0f0; padding-bottom: 10px; }

        .big-char { font-size: 48px; font-weight: bold; color: #333; }

        .pinyin { font-size: 24px; color: var(--primary-color); font-weight: 500; cursor: pointer; }

        .section-title { font-size: 14px; color: #999; margin-top: 20px; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; }

        .content-text { font-size: 16px; color: #444; line-height: 1.6; min-height: 40px; }

        .tags { display: flex; gap: 10px; flex-wrap: wrap; }

        .tag { background: #f0f2f5; padding: 5px 12px; border-radius: 15px; color: #555; font-size: 14px; }

        .ai-note { background: #fff7e6; border-left: 4px solid #ffc107; padding: 10px 15px; margin-top: 20px; font-size: 15px; color: #666; border-radius: 0 8px 8px 0; }

        /* åŠ è½½åŠ¨ç”» */

        .loading-dots:after { content: ' .'; animation: dots 1s steps(5, end) infinite;}

        @keyframes dots { 0%, 20% { color: rgba(0,0,0,0); text-shadow: .25em 0 0 rgba(0,0,0,0), .5em 0 0 rgba(0,0,0,0);} 40% { color: #333; text-shadow: .25em 0 0 rgba(0,0,0,0), .5em 0 0 rgba(0,0,0,0);} 60% { text-shadow: .25em 0 0 #333, .5em 0 0 rgba(0,0,0,0);} 80%, 100% { text-shadow: .25em 0 0 #333, .5em 0 0 #333;}}
</style>
</head>
<body>
<h1>âœï¸ AI æ±‰å­—ç§æ•™ (Gemini API)</h1>
<div class="search-box">
<input type="text" id="inputChar" maxlength="1" value="æ™º" placeholder="è¾“å…¥å•å­—">
<button class="search-btn" id="btnStart" onclick="loadNewCharacter()">å¼€å§‹å­¦ä¹ </button>
</div>
<div class="container">
<div class="writer-section">
<div id="character-target-div"></div>
<div class="controls">
<button class="btn-sm" onclick="animateChar()">ğŸ¥ æ¼”ç¤ºç¬”é¡º</button>
<button class="btn-sm" onclick="quizChar()">âœï¸ æçº¢æµ‹éªŒ</button>
</div>
</div>
<div class="info-section">
<div class="header-group">
<div class="big-char" id="dispChar">...</div>
<div class="pinyin" onclick="speak()" id="dispPinyin">...</div>
</div>
<div class="section-title">AI é‡Šä¹‰</div>
<div class="content-text" id="dispDefinition">è¯·åœ¨ä¸Šæ–¹è¾“å…¥æ±‰å­—...</div>
<div class="section-title">å¸¸ç”¨ç»„è¯</div>
<div class="tags" id="dispCompounds"></div>
<div class="section-title">AI åŠ©è®° / å­—æº</div>
<div class="ai-note" id="dispNote">
<strong style="display:block; margin-bottom:5px;">ğŸ¤– è®°å¿†å°è´´å£«ï¼š</strong>
<span id="dispMnemonic">...</span>
</div>
</div>
</div>
<script>

        // ==========================================

        // ğŸ”‘ é…ç½®åŒºåŸŸ

        // ==========================================

        // âš ï¸ è¯·åœ¨è¿™é‡Œå¡«å…¥ä½ ç”³è¯·çš„ Google Gemini API Key

        const API_KEY = 'AIzaSyBR00b8RjyYBWedF-n0eAQHM-eQ1nFHW68'; 

        // ==========================================

        let writer = null;

        // 1. è°ƒç”¨ Google Gemini API

        async function fetchAIInfo_(char) {

            if (!API_KEY || API_KEY.includes('åœ¨æ­¤å¤„ç²˜è´´')) {

                alert("è¯·å…ˆåœ¨ä»£ç ä¸­å¡«å…¥ä½ çš„ Gemini API Keyï¼");

                return null;

            }

            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${API_KEY}`;

            // ç²¾å¿ƒè®¾è®¡çš„ Promptï¼Œå¼ºåˆ¶ AI è¿”å› JSON æ ¼å¼

            const prompt = `

            ä½ æ˜¯ä¸€ä¸ªä¸­æ–‡æ•™å­¦åŠ©æ‰‹ã€‚è¯·åˆ†ææ±‰å­—â€œ${char}â€ã€‚

            è¯·ä¸¥æ ¼åªè¿”å›ä¸€ä¸ª JSON å¯¹è±¡ï¼Œä¸è¦åŒ…å« markdown æ ¼å¼ï¼ˆå¦‚ \`\`\`jsonï¼‰ï¼Œä¸è¦åŒ…å«å…¶ä»–å¤šä½™æ–‡å­—ã€‚

            JSON æ ¼å¼è¦æ±‚å¦‚ä¸‹ï¼š

            {

                "pinyin": "å¸¦å£°è°ƒçš„æ‹¼éŸ³ (ä¾‹å¦‚ï¼šmÃ­ng)",

                "definition": "è¿™ä¸ªå­—çš„å«ä¹‰è§£é‡Šï¼Œç®€å•æ˜“æ‡‚ï¼Œé€‚åˆå­¦ç”Ÿ",

                "compounds": ["ç»„è¯1", "ç»„è¯2", "ç»„è¯3"],

                "mnemonic": "ä¸€æ®µå…³äºè¿™ä¸ªå­—çš„åŠ©è®°æŠ€å·§ã€æ‹†å­—æ³•æˆ–å­—æºå°æ•…äº‹ï¼Œæœ‰è¶£ä¸€ç‚¹"

            }

            `;

            const data = {

                contents: [{

                    parts: [{ text: prompt }]

                }]

            };

            try {

                const response = await fetch(url, {

                    method: 'POST',

                    headers: { 'Content-Type': 'application/json' },

                    body: JSON.stringify(data)

                });

                const result = await response.json();

                // è§£æ Gemini çš„è¿”å›ç»“æ„

                let rawText = result.candidates[0].content.parts[0].text;

                // æ¸…ç†å¯èƒ½å­˜åœ¨çš„ Markdown æ ‡è®°

                rawText = rawText.replace(/```json/g, '').replace(/```/g, '').trim();

                return JSON.parse(rawText);

            } catch (error) {

                console.error("AI API Error:", error);

                alert("AI ç”Ÿæˆå¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ– API Keyã€‚");

                return {

                    pinyin: "Error",

                    definition: "æ— æ³•è¿æ¥åˆ° AI è·å–é‡Šä¹‰ã€‚",

                    compounds: [],

                    mnemonic: "ç½‘ç»œé”™è¯¯"

                };

            }

        }
        async function fetchAIInfo(char) {
            const url = `https://api.xdict.cn/zi/${encodeURIComponent(char)}`;

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error('API Error');

                const data = await response.json();
                console.info(data)
                // æå–å¹¶æ ¼å¼åŒ–æ•°æ®ï¼ˆèŒå…¸è¿”å›ç»“æ„éœ€æ˜ å°„åˆ°ä½ çš„JSONæ ¼å¼ï¼‰
                const heteronyms = data.heteronyms[0] || {};
                const definitions = heteronyms.definitions || [];
                const definition = definitions[0]?.def || 'æœªæ‰¾åˆ°é‡Šä¹‰';
                const pinyin = heteronyms.bopomofo || 'æœªçŸ¥';  // å¯è½¬æ¢ä¸ºæ±‰è¯­æ‹¼éŸ³

                return {
                    pinyin: pinyin.replace(/ËŠ|Ë‡|Ë‹|Ë™/g, ''),  // ç®€åŒ–å£°è°ƒ
                    definition: definition,
                    compounds: heteronyms.examples?.slice(0, 3) || ['ç¤ºä¾‹1', 'ç¤ºä¾‹2', 'ç¤ºä¾‹3'],  // æå–ç¤ºä¾‹è¯
                    mnemonic: `æœ‰è¶£å°è´´å£«ï¼š${char} çš„å­—æºå¯èƒ½æºè‡ªå¤ä»£è±¡å½¢ï¼Œæƒ³è±¡å®ƒåƒ...`  // å¯è‡ªå®šä¹‰åŠ©è®°
                };
            } catch (error) {
                console.error("API Error:", error);
                return {
                    pinyin: "Error",
                    definition: "æ— æ³•è·å–é‡Šä¹‰ã€‚",
                    compounds: [],
                    mnemonic: "ç½‘ç»œé”™è¯¯"
                };
            }
        }

// ä½¿ç”¨ç¤ºä¾‹
fetchCharInfo('æ˜').then(info => console.log(info));
        // 2. ç•Œé¢åŠ è½½é€»è¾‘

        async function loadNewCharacter() {

            const char = document.getElementById('inputChar').value.trim();

            if (!char || char.length > 1 || !/[\u4e00-\u9fa5]/.test(char)) {

                alert("è¯·è¾“å…¥å•ä¸ªä¸­æ–‡å­—ç¬¦");

                return;

            }

            // é”å®šæŒ‰é’®ï¼Œæ˜¾ç¤ºåŠ è½½çŠ¶æ€

            const btn = document.getElementById('btnStart');

            btn.disabled = true;

            btn.innerText = "AI æ€è€ƒä¸­...";

            document.getElementById('dispChar').innerText = char;

            document.getElementById('dispPinyin').innerText = "åŠ è½½ä¸­...";

            document.getElementById('dispDefinition').innerHTML = '<span class="loading-dots">AI æ­£åœ¨æŸ¥è¯¢è§£é‡Š</span>';

            document.getElementById('dispMnemonic').innerText = "...";

            document.getElementById('dispCompounds').innerHTML = "";

            // A. å¹¶è¡Œæ‰§è¡Œï¼šåˆå§‹åŒ–ç¬”é¡º (æœ¬åœ°/CDN)

            initWriter(char);

            // B. å¹¶è¡Œæ‰§è¡Œï¼šè¯·æ±‚ AI (ç½‘ç»œè¯·æ±‚)

            const aiData = await fetchAIInfo(char);

            if (aiData) {

                document.getElementById('dispPinyin').innerText = aiData.pinyin + " ğŸ”Š";

                document.getElementById('dispDefinition').innerText = aiData.definition;

                document.getElementById('dispMnemonic').innerText = aiData.mnemonic;

                const compoundsContainer = document.getElementById('dispCompounds');

                aiData.compounds.forEach(word => {

                    const span = document.createElement('span');

                    span.className = 'tag';

                    span.innerText = word;

                    compoundsContainer.appendChild(span);

                });

            }

            // æ¢å¤æŒ‰é’®

            btn.disabled = false;

            btn.innerText = "å¼€å§‹å­¦ä¹ ";

        }

        // 3. Hanzi Writer åˆå§‹åŒ–

        function initWriter(char) {

            document.getElementById('character-target-div').innerHTML = '';

            writer = HanziWriter.create('character-target-div', char, {

                width: 260,

                height: 260,

                padding: 5,

                showOutline: true,

                strokeAnimationSpeed: 1.5,

                delayBetweenStrokes: 200,

                radicalColor: '#4a90e2',

            });

            setTimeout(() => { writer.animateCharacter(); }, 500);

        }

        // 4. è¾…åŠ©åŠŸèƒ½

        function animateChar() { if(writer) writer.animateCharacter(); }

        function quizChar() {

            if(writer) {

                writer.quiz({

                    onComplete: function() { alert('å¤ªæ£’äº†ï¼ä¹¦å†™æ­£ç¡®ï¼'); }

                });

            }

        }

        function speak() {

            const text = document.getElementById('inputChar').value;

            const u = new SpeechSynthesisUtterance(text);

            u.lang = 'zh-CN';

            window.speechSynthesis.speak(u);

        }

        // åˆå§‹åŠ è½½

        window.onload = function() {

            // æç¤ºç”¨æˆ·å¡« Key

            if(API_KEY.includes('_GOOGLE_API_KEY')) {

                alert("æ¬¢è¿ï¼è¯·è®°å¾—ç”¨ä»£ç ç¼–è¾‘å™¨æ‰“å¼€æ­¤æ–‡ä»¶ï¼Œå¹¶åœ¨ç¬¬109è¡Œå¡«å…¥ä½ çš„ Google API Key æ‰èƒ½ä½¿ç”¨ AI åŠŸèƒ½ã€‚");

            } else {

                loadNewCharacter();

            }

        }
</script>
</body>
</html>
 